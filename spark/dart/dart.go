package dart

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"
	"os"
	"path"

	"github.com/iancoleman/strcase"
	"github.com/nanoteck137/pyrin/spark"
	"github.com/nanoteck137/pyrin/utils"
)

const indent = "  "
const warningMessage = "DO NOT EDIT THIS: This file was generated by the Pyrin Dart Generator"

//go:embed base_client.dart
var baseClientSource string

var _ spark.Generator = (*DartGenerator)(nil)

type DartGenerator struct {
	NameMapping map[string]string
}

func (g *DartGenerator) Generate(serverDef *spark.ServerDef, resolver *spark.Resolver, outputDir string) error {
	buf := &bytes.Buffer{}
	err := g.generateTypeDefinitionCode(buf, resolver)
	if err != nil {
		return err
	}

	p := path.Join(outputDir, "types.dart")
	err = os.WriteFile(p, buf.Bytes(), 0644)
	if err != nil {
		return err
	}

	buf = &bytes.Buffer{}
	err = g.generateClientCode(buf, serverDef)
	if err != nil {
		return err
	}

	p = path.Join(outputDir, "client.dart")
	err = os.WriteFile(p, buf.Bytes(), 0644)
	if err != nil {
		return err
	}

	p = path.Join(outputDir, "base_client.dart")
	err = os.WriteFile(p, []byte(baseClientSource), 0644)
	if err != nil {
		return err
	}

	return nil
}

func (g *DartGenerator) mapName(name string) string {
	if g.NameMapping == nil || name == "" {
		return name
	}

	if newName, exists := g.NameMapping[name]; exists {
		return newName
	}

	return name
}

func (g *DartGenerator) generateTypeDefinitionCode(out io.Writer, resolver *spark.Resolver) error {
	w := spark.NewCodeWriter(out, indent)

	w.IndentWritef("// %s\n", warningMessage)
	w.IndentWritef("import 'package:json_annotation/json_annotation.dart';\n")
	w.IndentWritef("\n")

	w.IndentWritef("part 'types.g.dart';\n")
	w.IndentWritef("\n")

	for _, s := range resolver.ResolvedSymbols {
		rs := s.ResolvedStruct

		err := g.generateStruct(&w, rs)
		if err != nil {
			return err
		}
	}

	return nil
}

func (g *DartGenerator) generateStruct(w *spark.CodeWriter, rs *spark.ResolvedStruct) error {
	name := g.mapName(rs.Name)

	w.IndentWritef("@JsonSerializable()\n")
	w.IndentWritef("class %s {\n", name)
	w.Indent()

	for _, field := range rs.Fields {
		g.generateField(w, &field)
	}

	w.Writef("\n")

	w.Writef("  %s({", name)
	for i, f := range rs.Fields {
		name := g.mapName(f.Name)

		if i != 0 {
			w.Writef(", ")
		}

		if !f.OmitEmpty {
			w.Writef("required ")
		}

		w.Writef("this.%s", name)
	}

	w.Writef("});\n")

	w.Writef("\n")

	w.Writef("  factory %s.fromJson(Map<String, dynamic> json) => _$%sFromJson(json);\n", name, name)
	w.Writef("  Map<String, dynamic> toJson() => _$%sToJson(this);\n", name)

	w.Unindent()
	w.Writef("}\n")
	w.Writef("\n")

	return nil
}

func (g *DartGenerator) generateFieldType(w *spark.CodeWriter, ty spark.FieldType) {
	switch t := ty.(type) {
	case *spark.FieldTypeString:
		w.Writef("String")
	case *spark.FieldTypeInt:
		w.Writef("int")
	case *spark.FieldTypeFloat:
		w.Writef("float")
	case *spark.FieldTypeBoolean:
		w.Writef("bool")
	case *spark.FieldTypeArray:
		w.Writef("List<")
		g.generateFieldType(w, t.ElementType)
		w.Writef(">")
	case *spark.FieldTypePtr:
		g.generateFieldType(w, t.BaseType)
		w.Writef("?")
	case *spark.FieldTypeStructRef:
		name := g.mapName(t.Name)
		w.Writef("%s", name)
	default:
		panic(fmt.Sprintf("generateFieldType: unknown type: %t", t))
	}
}

func (g *DartGenerator) generateField(w *spark.CodeWriter, field *spark.ResolvedField) {
	jsonName := field.Name
	name := g.mapName(field.Name)

	w.IndentWritef("@JsonKey(name: \"%s\")\n", jsonName)
	w.IndentWritef("final ")
	g.generateFieldType(w, field.Type)

	if field.OmitEmpty && !isPointer(field.Type) {
		w.Writef("?")
	}
	w.Writef(" %s;\n", name)
}

func (g *DartGenerator) generateApiEndpoint(w *spark.CodeWriter, e *spark.Endpoint) error {
	newPath, args := utils.ReplacePathArgs(e.Path, g.mapName, func(name string) string {
		return "$" + name
	})

	name := g.mapName(strcase.ToLowerCamel(e.Name))
	response := g.mapName(e.Response)
	body := g.mapName(e.Body)

	if response == "" {
		response = "NoBody"
	}

	w.IndentWritef("AsyncResultDart<%s, ApiError> %s(", response, name)
	for _, arg := range args {
		w.Writef("String %s, ", arg)
	}

	if body != "" {
		w.Writef("%s body, ", body)
	}

	w.Writef("{")
	w.Writef("RequestOptions? options")
	w.Writef("}")

	w.Writef(") async {\n")
	w.Indent()

	w.IndentWritef("final res = await request(\"%s\", \"%s\"", e.Method, newPath)
	w.Writef(", options: options")
	if e.Body != "" {
		w.Writef(", body: body.toJson()")
	}
	w.Writef(");\n")

	if response != "NoBody" {
		w.IndentWritef("return res.map((success) => %s.fromJson(success));\n", response)
	} else {
		w.IndentWritef("return res.map((success) => NoBody());\n")
	}

	w.Unindent()
	w.IndentWritef("}\n")

	return nil
}

func (g *DartGenerator) generateFormEndpoint(w *spark.CodeWriter, e *spark.Endpoint) error {
	newPath, args := utils.ReplacePathArgs(e.Path, g.mapName, func(name string) string {
		return "$" + name
	})

	name := g.mapName(strcase.ToLowerCamel(e.Name))
	response := g.mapName(e.Response)
	// body := g.mapName(e.Body)

	if response == "" {
		response = "NoBody"
	}

	w.IndentWritef("AsyncResultDart<%s, ApiError> %s(", response, name)
	for _, arg := range args {
		w.Writef("String %s, ", arg)
	}

	w.Writef("FormDataType body, ")

	// if body != "" {
	// 	w.Writef("%s body, ", body)
	// }

	w.Writef("{")
	w.Writef("RequestOptions? options")
	w.Writef("}")

	w.Writef(") async {\n")
	w.Indent()

	w.IndentWritef("final res = await requestForm(\"%s\", \"%s\"", e.Method, newPath)
	w.Writef(", options: options")
	w.Writef(", body: body")
	w.Writef(");\n")

	if response != "NoBody" {
		w.IndentWritef("return res.map((success) => %s.fromJson(success));\n", response)
	} else {
		w.IndentWritef("return res.map((success) => NoBody());\n")
	}

	w.Unindent()
	w.IndentWritef("}\n")

	return nil
}

func (g *DartGenerator) generateUrlForEndpoint(w *spark.CodeWriter, e *spark.Endpoint) error {
	newPath, args := utils.ReplacePathArgs(e.Path, g.mapName, func(name string) string {
		return "$" + name
	})

	name := g.mapName(strcase.ToLowerCamel(e.Name))

	w.IndentWritef("String %s(", name)
	for i, arg := range args {
		if i > 0 {
			w.Writef(", ")
		}

		w.Writef("String %s", arg)
	}

	w.Writef(") {\n")
	w.Indent()

	w.IndentWritef("return createUrl(baseUrl, ")
	w.Writef("\"%s\"", newPath)
	w.Writef(");\n")

	w.Unindent()
	w.IndentWritef("}\n")

	return nil
}

func (g *DartGenerator) generateClientCode(out io.Writer, serverDef *spark.ServerDef) error {
	w := spark.NewCodeWriter(out, indent)

	w.Writef("// %s\n", warningMessage)
	w.IndentWritef("import 'package:result_dart/result_dart.dart';\n")
	w.IndentWritef("\n")

	w.IndentWritef("import './types.dart';\n")
	w.IndentWritef("import './base_client.dart';\n")
	w.IndentWritef("\n")

	w.IndentWritef("class ApiClient extends BaseApiClient {\n")
	w.Indent()

	w.IndentWritef("ApiClient({super.baseUrl}) {\n")
	w.Indent()

	w.IndentWritef("url = ClientUrls(baseUrl);\n")

	w.Unindent()
	w.IndentWritef("}\n")

	w.Writef("\n")

	w.IndentWritef("late ClientUrls url;")

	for _, endpoint := range serverDef.Endpoints {
		w.IndentWritef("\n")

		switch endpoint.Type {
		case spark.EndpointTypeApi:
			err := g.generateApiEndpoint(&w, &endpoint)
			if err != nil {
				return err
			}
		case spark.EndpointTypeForm:
			err := g.generateFormEndpoint(&w, &endpoint)
			if err != nil {
				return err
			}
		}
	}

	w.Unindent()
	w.IndentWritef("}\n")

	w.Writef("\n")

	w.IndentWritef("class ClientUrls {\n")
	w.Indent()

	w.IndentWritef("ClientUrls(this.baseUrl);\n")
	w.Writef("\n")

	w.IndentWritef("String baseUrl;\n")

	for _, endpoint := range serverDef.Endpoints {
		w.IndentWritef("\n")

		err := g.generateUrlForEndpoint(&w, &endpoint)
		if err != nil {
			return err
		}
	}

	w.Unindent()
	w.IndentWritef("}\n")

	return nil
}

func isPointer(ty spark.FieldType) bool {
	switch t := ty.(type) {
	case *spark.FieldTypeArray:
		return isPointer(t.ElementType)
	case *spark.FieldTypePtr:
		return true
	}

	return false
}
