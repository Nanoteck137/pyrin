package dart

import (
	"bytes"
	_ "embed"
	"io"
	"os"
	"path"

	"github.com/iancoleman/strcase"
	"github.com/nanoteck137/pyrin/spark"
	"github.com/nanoteck137/pyrin/utils"
)

const indent = "  "
const warningMessage = "DO NOT EDIT THIS: This file was generated by the Pyrin Dart Generator"

//go:embed base_client.dart
var baseClientSource string

var _ spark.Generator = (*DartGenerator)(nil)

type DartGenerator struct {
	NameMapping map[string]string
}

func (g *DartGenerator) Generate(serverDef *spark.ServerDef, resolver *spark.Resolver, outputDir string) error {
	buf := &bytes.Buffer{}
	err := g.generateTypeDefinitionCode(buf, resolver)
	if err != nil {
		return err
	}

	p := path.Join(outputDir, "types.dart")
	err = os.WriteFile(p, buf.Bytes(), 0644)
	if err != nil {
		return err
	}

	buf = &bytes.Buffer{}
	err = g.generateClientCode(buf, serverDef)
	if err != nil {
		return err
	}

	p = path.Join(outputDir, "client.dart")
	err = os.WriteFile(p, buf.Bytes(), 0644)
	if err != nil {
		return err
	}

	p = path.Join(outputDir, "base_client.dart")
	err = os.WriteFile(p, []byte(baseClientSource), 0644)
	if err != nil {
		return err
	}

	return nil
}

func (g *DartGenerator) mapName(name string) string {
	if g.NameMapping == nil || name == "" {
		return name
	}

	if newName, exists := g.NameMapping[name]; exists {
		return newName
	}

	return name
}

func (g *DartGenerator) generateTypeDefinitionCode(out io.Writer, resolver *spark.Resolver) error {
	w := spark.NewCodeWriter(out, indent)

	w.IndentWritef("// %s\n", warningMessage)
	w.IndentWritef("import 'package:json_annotation/json_annotation.dart';\n")
	w.IndentWritef("\n")

	w.IndentWritef("part 'types.g.dart';\n")
	w.IndentWritef("\n")

	for _, s := range resolver.Symbols {
		if s.State != spark.SymbolResolved {
			continue
		}

		rs := s.ResolvedStruct

		err := g.generateStruct(&w, rs)
		if err != nil {
			return err
		}
	}

	return nil
}

func (g *DartGenerator) generateStruct(w *spark.CodeWriter, rs *spark.ResolvedStruct) error {
	name := g.mapName(rs.Name)

	w.IndentWritef("@JsonSerializable()\n")
	w.IndentWritef("class %s {\n", name)
	w.Indent()

	for _, field := range rs.Fields {
		g.generateField(w, &field)
	}

	w.Writef("\n")

	w.Writef("  %s({", name)
	for i, f := range rs.Fields {
		name := g.mapName(f.Name)

		if i != 0 {
			w.Writef(", ")
		}

		if !f.OmitEmpty {
			w.Writef("required ")
		}

		w.Writef("this.%s", name)
	}

	w.Writef("});\n")

	w.Writef("\n")

	w.Writef("  factory %s.fromJson(Map<String, dynamic> json) => _$%sFromJson(json);\n", name, name)
	w.Writef("  Map<String, dynamic> toJson() => _$%sToJson(this);\n", name)

	w.Unindent()
	w.Writef("}\n")
	w.Writef("\n")

	return nil
}

func (g *DartGenerator) generateFieldType(w *spark.CodeWriter, ty spark.FieldType) {
	switch t := ty.(type) {
	case *spark.FieldTypeString:
		w.Writef("String")
	case *spark.FieldTypeInt:
		w.Writef("int")
	case *spark.FieldTypeBoolean:
		w.Writef("bool")
	case *spark.FieldTypeArray:
		w.Writef("List<")
		g.generateFieldType(w, t.ElementType)
		w.Writef(">")
	case *spark.FieldTypePtr:
		g.generateFieldType(w, t.BaseType)
		w.Writef("?")
	default:
		// TODO(patrik): Better error
		panic("Unknown type")
	}
}

func (g *DartGenerator) generateField(w *spark.CodeWriter, field *spark.ResolvedField) {
	jsonName := field.Name
	name := g.mapName(field.Name)

	w.IndentWritef("@JsonKey(name: \"%s\")\n", jsonName)
	w.IndentWritef("final ")
	g.generateFieldType(w, field.Type)

	if field.OmitEmpty && !isPointer(field.Type) {
		w.Writef("?")
	}
	w.Writef(" %s;\n", name)
}

func (g *DartGenerator) generateApiEndpoint(w *spark.CodeWriter, e *spark.Endpoint) error {
	newPath, args := utils.ReplacePathArgs(e.Path, g.mapName, func(name string) string {
		return "$" + name
	})

	name := g.mapName(strcase.ToLowerCamel(e.Name))
	response := g.mapName(e.Response)
	body := g.mapName(e.Body)

	if response == "" {
		response = "NoBody"
	}

	w.IndentWritef("AsyncResultDart<%s, ApiError> %s(", response, name)
	for _, arg := range args {
		w.Writef("String %s, ", arg)
	}

	if body != "" {
		w.Writef("%s body, ", body)
	}

	w.Writef("{")
	w.Writef("RequestOptions? options")
	w.Writef("}")

	w.Writef(") async {\n")
	w.Indent()

	w.IndentWritef("final res = await request(\"%s\", \"%s\"", e.Method, newPath)
	w.Writef(", options: options")
	if e.Body != "" {
		w.Writef(", body: body.toJson()")
	}
	w.Writef(");\n")

	if response != "NoBody" {
		w.IndentWritef("return res.map((success) => %s.fromJson(success));\n", response)
	} else {
		w.IndentWritef("return res.map((success) => NoBody());\n")
	}

	w.Unindent()
	w.IndentWritef("}\n")

	return nil
}

// func generateFormApiEndpoint(w *utils.CodeWriter, e *spec.FormApiEndpoint) error {
// 	var args []string
// 	parts := strings.Split(e.Path, "/")
// 	endpointHasArgs := false
//
// 	for i, p := range parts {
// 		if len(p) == 0 {
// 			continue
// 		}
//
// 		if p[0] == ':' {
// 			name := p[1:]
// 			args = append(args, name)
//
// 			parts[i] = fmt.Sprintf("${%s}", name)
//
// 			endpointHasArgs = true
// 		}
// 	}
//
// 	newEndpoint := strings.Join(parts, "/")
//
// 	w.IWritef("%s(", strcase.ToLowerCamel(e.Name))
//
// 	for _, arg := range args {
// 		w.Writef("%s: string, ", arg)
// 	}
//
// 	w.Writef("formData: FormData, ")
// 	w.Writef("options?: ExtraOptions")
//
// 	w.Writef(") {\n")
//
// 	w.Indent()
//
// 	w.IWritef("return this.requestWithFormData(")
//
// 	if endpointHasArgs {
// 		w.Writef("`%s`", newEndpoint)
// 	} else {
// 		w.Writef("\"%s\"", newEndpoint)
// 	}
//
// 	w.Writef(", \"%s\"", e.Method)
//
// 	if e.ResponseType != "" {
// 		w.Writef(", api.%s", e.ResponseType)
// 	} else {
// 		w.Writef(", z.undefined()")
// 	}
//
// 	w.Writef(", z.undefined()")
//
// 	w.Writef(", formData")
//
// 	w.Writef(", options")
//
// 	w.Writef(")\n")
// 	w.Unindent()
//
// 	w.IWritef("}\n")
//
// 	return nil
// }

func (g *DartGenerator) generateClientCode(out io.Writer, serverDef *spark.ServerDef) error {
	w := spark.NewCodeWriter(out, indent)

	w.Writef("// %s\n", warningMessage)
	w.IndentWritef("import 'package:result_dart/result_dart.dart';\n")
	w.IndentWritef("\n")

	w.IndentWritef("import './types.dart';\n")
	w.IndentWritef("import './base_client.dart';\n")
	w.IndentWritef("\n")

	w.IndentWritef("class ApiClient extends BaseApiClient {\n")
	w.Indent()

	w.IndentWritef("ApiClient({super.baseUrl});\n")

	for _, endpoint := range serverDef.Endpoints {
		w.IndentWritef("\n")

		switch endpoint.Type {
		case spark.EndpointTypeApi:
			err := g.generateApiEndpoint(&w, &endpoint)
			if err != nil {
				return err
			}
		}
	}

	w.Unindent()
	w.IndentWritef("}\n")

	return nil
}

func isPointer(ty spark.FieldType) bool {
	switch t := ty.(type) {
	case *spark.FieldTypeArray:
		return isPointer(t.ElementType)
	case *spark.FieldTypePtr:
		return true
	}

	return false
}
