package golang

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"
	"os"
	"path"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/nanoteck137/pyrin/spark"
	"github.com/nanoteck137/pyrin/utils"
)

const indent = "\t"
const warningMessage = "DO NOT EDIT THIS: This file was generated by the Pyrin Golang Generator"

//go:embed base_client.go.txt
var baseClientSource string

var _ spark.Generator = (*GolangGenerator)(nil)

type GolangGenerator struct{
	NameMapping map[string]string
}

func (g *GolangGenerator) Generate(serverDef *spark.ServerDef, resolver *spark.Resolver, outputDir string) error {
	buf := &bytes.Buffer{}
	err := g.generateTypeDefinitionCode(buf, resolver)
	if err != nil {
		return err
	}

	p := path.Join(outputDir, "types.go")
	err = os.WriteFile(p, buf.Bytes(), 0644)
	if err != nil {
		return err
	}

	buf = &bytes.Buffer{}
	err = g.generateClientCode(buf, serverDef)
	if err != nil {
		return err
	}

	p = path.Join(outputDir, "client.go")
	err = os.WriteFile(p, buf.Bytes(), 0644)
	if err != nil {
		return err
	}

	p = path.Join(outputDir, "base_client.go")
	err = os.WriteFile(p, []byte(baseClientSource), 0644)
	if err != nil {
		return err
	}

	return nil
}

func (g *GolangGenerator) mapName(name string) string {
	if g.NameMapping == nil || name == "" {
		return name
	}

	if newName, exists := g.NameMapping[name]; exists {
		return newName
	}

	return name
}

func (g *GolangGenerator) generateTypeDefinitionCode(out io.Writer, resolver *spark.Resolver) error {
	w := spark.NewCodeWriter(out, indent)

	w.IndentWritef("// %s\n", warningMessage)
	w.IndentWritef("package api\n")
	w.IndentWritef("\n")

	for _, s := range resolver.Symbols {
		if s.State != spark.SymbolResolved {
			continue
		}

		rs := s.ResolvedStruct

		err := g.generateStruct(&w, rs)
		if err != nil {
			return err
		}
	}

	return nil
}

func (g *GolangGenerator) generateStruct(w *spark.CodeWriter, rs *spark.ResolvedStruct) error {
	name := g.mapName(rs.Name)

	w.IndentWritef("type %s struct {\n", name)

	w.Indent()
	for _, field := range rs.Fields {
		err := w.WriteIndent()
		if err != nil {
			return err
		}

		g.generateField(w, &field)
	}
	w.Unindent()

	// TODO(patrik): Replace with f.Writef
	fmt.Fprintln(w, "}")
	fmt.Fprintln(w)

	return nil
}

func (g *GolangGenerator) generateFieldType(w io.Writer, ty spark.FieldType) {
	switch t := ty.(type) {
	case *spark.FieldTypeString:
		fmt.Fprint(w, "string")
	case *spark.FieldTypeInt:
		fmt.Fprint(w, "int")
	case *spark.FieldTypeBoolean:
		fmt.Fprint(w, "bool")
	case *spark.FieldTypeArray:
		fmt.Fprintf(w, "[]")
		g.generateFieldType(w, t.ElementType)
	case *spark.FieldTypePtr:
		fmt.Fprintf(w, "*")
		g.generateFieldType(w, t.BaseType)
	default:
		// TODO(patrik): Better error
		panic("Unknown type")
	}
}

func (g *GolangGenerator) generateField(w *spark.CodeWriter, field *spark.ResolvedField) {
	jsonName := field.Name
	name := g.mapName(strcase.ToCamel(field.Name))

	_, isPointer := field.Type.(*spark.FieldTypePtr)

	w.Writef("%s ", name)
	g.generateFieldType(w, field.Type)
	w.Writef(" `")
	w.Writef("json:\"")
	w.Writef("%s", jsonName)
	// TODO(patrik): Should this be here?
	if isPointer {
		w.Writef(",omitempty")
	}
	w.Writef("\"")

	w.Writef("`")
	w.Writef("\n")
}

func (g *GolangGenerator) generateApiEndpoint(w *spark.CodeWriter, e *spark.Endpoint) error {
	newPath, args := utils.ReplacePathArgs(e.Path, g.mapName, func(name string) string {
		return "%v"
	})

	name := g.mapName(e.Name)
	response := g.mapName(e.Response)
	body := g.mapName(e.Body)

	if response == "" {
		response = "any"
	}

	b := strings.Builder{}

	for _, v := range args {
		fmt.Fprintf(&b, "%s string, ", v)
	}

	if body != "" {
		fmt.Fprintf(&b, "body %s, ", body)
	}

	fmt.Fprintf(&b, "options Options")

	w.IndentWritef("func (c *Client) %v(%s) (*%s, error) {\n", name, b.String(), response)
	w.Indent()

	if len(args) > 0 {
		b := strings.Builder{}
		for _, v := range args {
			fmt.Fprintf(&b, ", %s", v)
		}

		w.IndentWritef("path := Sprintf(\"%v\"%s)\n", newPath, b.String())
	} else {
		w.IndentWritef("path := \"%v\"\n", e.Path)
	}

	w.IndentWritef("url, err := createUrl(c.addr, path, options.Query)\n")
	w.IndentWritef("if err != nil {\n")
	w.Indent()
	w.IndentWritef("return nil, err\n")
	w.Unindent()
	w.IndentWritef("}\n")

	w.Writef("\n")

	w.IndentWritef("data := RequestData{\n")
	w.Indent()

	w.IndentWritef("Url: url,\n")
	w.IndentWritef("Method: \"%v\",\n", e.Method)
	w.IndentWritef("ClientHeaders: c.Headers,\n")
	w.IndentWritef("Headers: options.Header,\n")

	w.Unindent()
	w.IndentWritef("}\n")

	w.IndentWritef("return Request[%s](data, ", response)
	if body != "" {
		w.Writef("body")
	} else {
		w.Writef("nil")
	}
	w.Writef(")\n")

	w.Unindent()
	w.IndentWritef("}\n")

	return nil
}

func (g *GolangGenerator) generateFormEndpoint(w *spark.CodeWriter, e *spark.Endpoint) error {
	newPath, args := utils.ReplacePathArgs(e.Path, g.mapName, func(name string) string {
		return "%v"
	})

	name := g.mapName(e.Name)
	response := g.mapName(e.Response)
	// body := g.mapName(e.Body)

	if response == "" {
		response = "any"
	}

	b := strings.Builder{}

	for _, v := range args {
		fmt.Fprintf(&b, "%s string, ", v)
	}

	fmt.Fprintf(&b, "boundary string, ")
	fmt.Fprintf(&b, "body Reader, ")

	fmt.Fprintf(&b, "options Options")

	w.IndentWritef("func (c *Client) %v(%s) (*%s, error) {\n", name, b.String(), response)
	w.Indent()

	if len(args) > 0 {
		b := strings.Builder{}
		for _, v := range args {
			fmt.Fprintf(&b, ", %s", v)
		}

		w.IndentWritef("path := Sprintf(\"%v\"%s)\n", newPath, b.String())
	} else {
		w.IndentWritef("path := \"%v\"\n", e.Path)
	}

	w.IndentWritef("url, err := createUrl(c.addr, path, options.Query)\n")
	w.IndentWritef("if err != nil {\n")
	w.Indent()
	w.IndentWritef("return nil, err\n")
	w.Unindent()
	w.IndentWritef("}\n")

	w.Writef("\n")

	w.IndentWritef("data := RequestData{\n")
	w.Indent()

	w.IndentWritef("Url: url,\n")
	w.IndentWritef("Method: \"%v\",\n", e.Method)
	w.IndentWritef("ClientHeaders: c.Headers,\n")
	w.IndentWritef("Headers: options.Header,\n")

	w.Unindent()
	w.IndentWritef("}\n")

	w.IndentWritef("return RequestForm[%s](data, boundary, body)\n", response)

	w.Unindent()
	w.IndentWritef("}\n")

	return nil
}


// func generateFormApiEndpoint(w *utils.CodeWriter, e *spec.FormApiEndpoint) error {
// 	var args []string
// 	parts := strings.Split(e.Path, "/")
// 	endpointHasArgs := false
//
// 	for i, p := range parts {
// 		if len(p) == 0 {
// 			continue
// 		}
//
// 		if p[0] == ':' {
// 			name := p[1:]
// 			args = append(args, name)
//
// 			parts[i] = fmt.Sprintf("${%s}", name)
//
// 			endpointHasArgs = true
// 		}
// 	}
//
// 	newEndpoint := strings.Join(parts, "/")
//
// 	w.IWritef("%s(", strcase.ToLowerCamel(e.Name))
//
// 	for _, arg := range args {
// 		w.Writef("%s: string, ", arg)
// 	}
//
// 	w.Writef("formData: FormData, ")
// 	w.Writef("options?: ExtraOptions")
//
// 	w.Writef(") {\n")
//
// 	w.Indent()
//
// 	w.IWritef("return this.requestWithFormData(")
//
// 	if endpointHasArgs {
// 		w.Writef("`%s`", newEndpoint)
// 	} else {
// 		w.Writef("\"%s\"", newEndpoint)
// 	}
//
// 	w.Writef(", \"%s\"", e.Method)
//
// 	if e.ResponseType != "" {
// 		w.Writef(", api.%s", e.ResponseType)
// 	} else {
// 		w.Writef(", z.undefined()")
// 	}
//
// 	w.Writef(", z.undefined()")
//
// 	w.Writef(", formData")
//
// 	w.Writef(", options")
//
// 	w.Writef(")\n")
// 	w.Unindent()
//
// 	w.IWritef("}\n")
//
// 	return nil
// }

func (g *GolangGenerator) generateClientCode(w io.Writer, serverDef *spark.ServerDef) error {
	cw := spark.NewCodeWriter(w, indent)

	cw.IndentWritef("// DO NOT EDIT THIS: This file was generated by the Pyrin Golang Generator\n")
	cw.IndentWritef("package api\n")
	cw.Writef("\n")

	for _, endpoint := range serverDef.Endpoints {
		cw.IndentWritef("\n")

		switch endpoint.Type {
		case spark.EndpointTypeApi:
			err := g.generateApiEndpoint(&cw, &endpoint)
			if err != nil {
				return err
			}
		case spark.EndpointTypeForm:
			err := g.generateFormEndpoint(&cw, &endpoint)
			if err != nil {
				return err
			}
		}
	}

	return nil
}
