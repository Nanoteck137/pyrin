package typescript

import (
	"bytes"
	_ "embed"
	"io"
	"os"
	"path"

	"github.com/iancoleman/strcase"
	"github.com/nanoteck137/pyrin/spark"
	"github.com/nanoteck137/pyrin/utils"
)

const indent = "  "
const warningMessage = "DO NOT EDIT THIS: This file was generated by the Pyrin Typescript Generator"

//go:embed base_client.ts
var baseClientSource string

var _ spark.Generator = (*TypescriptGenerator)(nil)

type TypescriptGenerator struct {
	NameMapping map[string]string
}

func (g *TypescriptGenerator) Generate(serverDef *spark.ServerDef, resolver *spark.Resolver, outputDir string) error {
	buf := &bytes.Buffer{}
	err := g.generateTypeDefinitionCode(buf, resolver)
	if err != nil {
		return err
	}

	p := path.Join(outputDir, "types.ts")
	err = os.WriteFile(p, buf.Bytes(), 0644)
	if err != nil {
		return err
	}

	buf = &bytes.Buffer{}
	err = g.generateClientCode(buf, serverDef)
	if err != nil {
		return err
	}

	p = path.Join(outputDir, "client.ts")
	err = os.WriteFile(p, buf.Bytes(), 0644)
	if err != nil {
		return err
	}

	p = path.Join(outputDir, "base-client.ts")
	err = os.WriteFile(p, []byte(baseClientSource), 0644)
	if err != nil {
		return err
	}

	return nil
}

func (g *TypescriptGenerator) mapName(name string) string {
	if g.NameMapping == nil || name == "" {
		return name
	}

	if newName, exists := g.NameMapping[name]; exists {
		return newName
	}

	return name
}

func (g *TypescriptGenerator) generateTypeDefinitionCode(out io.Writer, resolver *spark.Resolver) error {
	w := spark.NewCodeWriter(out, indent)

	w.Writef("// %s\n", warningMessage)
	w.Writef("import { z } from \"zod\";\n")
	w.Writef("\n")

	for _, s := range resolver.ResolvedSymbols {
		rs := s.ResolvedStruct

		err := g.generateStruct(&w, rs)
		if err != nil {
			return err
		}
	}

	return nil
}

func (g *TypescriptGenerator) generateStruct(w *spark.CodeWriter, rs *spark.ResolvedStruct) error {
	name := g.mapName(rs.Name)

	err := w.Writef("export const %s = z.object({\n", name)
	if err != nil {
		return err
	}

	w.Indent()
	for _, field := range rs.Fields {
		err = w.WriteIndent()
		if err != nil {
			return err
		}

		g.generateField(w, &field)
	}
	w.Unindent()

	w.Writef("});\n")
	w.Writef("\n")
	w.Writef("export type %s = z.infer<typeof %s>;\n", name, name)
	w.Writef("\n")

	return nil
}

func (g *TypescriptGenerator) generateFieldType(w *spark.CodeWriter, ty spark.FieldType) {
	switch t := ty.(type) {
	case *spark.FieldTypeString:
		w.Writef("z.string()")
	case *spark.FieldTypeInt:
		w.Writef("z.number()")
	case *spark.FieldTypeFloat:
		w.Writef("z.number()")
	case *spark.FieldTypeBoolean:
		w.Writef("z.boolean()")
	case *spark.FieldTypeArray:
		w.Writef("z.array(")
		g.generateFieldType(w, t.ElementType)
		w.Writef(")")
	case *spark.FieldTypePtr:
		g.generateFieldType(w, t.BaseType)
		w.Writef(".nullable()")
	case *spark.FieldTypeStructRef:
		name := g.mapName(t.Name)
		w.Writef("%s", name)
	default:
		// TODO(patrik): Better error
		panic("Unknown type")
	}
}

func (g *TypescriptGenerator) generateField(w *spark.CodeWriter, field *spark.ResolvedField) {
	// name := g.mapName(field.Name)
	// NOTE(patrik): We can't map the name for zod schema because that would
	// screw up json key names, and zod don't have a way to rename object keys
	name := field.Name

	w.Writef("%s: ", name)
	g.generateFieldType(w, field.Type)

	if field.OmitEmpty {
		w.Writef(".optional()")
	}

	w.Writef(",\n")
}

func (g *TypescriptGenerator) generateApiEndpoint(w *spark.CodeWriter, e *spark.Endpoint) error {
	newPath, args := utils.ReplacePathArgs(e.Path, g.mapName, func(name string) string {
		return "${" + name + "}"
	})

	name := g.mapName(strcase.ToLowerCamel(e.Name))
	response := g.mapName(e.Response)
	body := g.mapName(e.Body)

	w.IndentWritef("%s", name)
	w.Writef("(")

	for _, arg := range args {
		w.Writef("%s: string, ", arg)
	}

	if body != "" {
		w.Writef("body: api.%s, ", body)
	}

	w.Writef("options?: ExtraOptions")

	w.Writef(") {\n")

	w.Indent()

	w.IndentWritef("return this.request(")

	if len(args) > 0 {
		w.Writef("`%s`", newPath)
	} else {
		w.Writef("\"%s\"", newPath)
	}

	w.Writef(", \"%s\"", e.Method)

	if response != "" {
		w.Writef(", api.%s", response)
	} else {
		w.Writef(", z.undefined()")
	}

	w.Writef(", z.any()")

	if e.Body != "" {
		w.Writef(", body")
	} else {
		w.Writef(", undefined")
	}

	w.Writef(", options")

	w.Writef(")\n")
	w.Unindent()

	w.IndentWritef("}\n")

	return nil
}

func (g *TypescriptGenerator) generateFormEndpoint(w *spark.CodeWriter, e *spark.Endpoint) error {
	newPath, args := utils.ReplacePathArgs(e.Path, g.mapName, func(name string) string {
		return "${" + name + "}"
	})

	name := g.mapName(strcase.ToLowerCamel(e.Name))
	response := g.mapName(e.Response)
	// body := g.mapName(e.Body)

	w.IndentWritef("%s", name)
	w.Writef("(")

	for _, arg := range args {
		w.Writef("%s: string, ", arg)
	}

	w.Writef("body: FormData, ")

	w.Writef("options?: ExtraOptions")

	w.Writef(") {\n")

	w.Indent()

	w.IndentWritef("return this.requestForm(")

	if len(args) > 0 {
		w.Writef("`%s`", newPath)
	} else {
		w.Writef("\"%s\"", newPath)
	}

	w.Writef(", \"%s\"", e.Method)

	if response != "" {
		w.Writef(", api.%s", response)
	} else {
		w.Writef(", z.undefined()")
	}

	w.Writef(", z.any()")

	w.Writef(", body")

	w.Writef(", options")

	w.Writef(")\n")
	w.Unindent()

	w.IndentWritef("}\n")

	return nil
}

func (g *TypescriptGenerator) generateUrlForEndpoint(w *spark.CodeWriter, e *spark.Endpoint) error {
	newPath, args := utils.ReplacePathArgs(e.Path, g.mapName, func(name string) string {
		return "${" + name + "}"
	})

	name := g.mapName(strcase.ToLowerCamel(e.Name))

	w.IndentWritef("%s", name)
	w.Writef("(")

	for i, arg := range args {
		if i > 0 {
			w.Writef(", ")
		}

		w.Writef("%s: string", arg)
	}

	w.Writef(") {\n")

	w.Indent()

	w.IndentWritef("return createUrl(this.baseUrl, ")

	if len(args) > 0 {
		w.Writef("`%s`", newPath)
	} else {
		w.Writef("\"%s\"", newPath)
	}

	w.Writef(")\n")
	w.Unindent()

	w.IndentWritef("}\n")

	return nil
}

func (g *TypescriptGenerator) generateClientCode(out io.Writer, serverDef *spark.ServerDef) error {
	w := spark.NewCodeWriter(out, indent)

	w.Writef("import { z } from \"zod\";\n")
	w.Writef("import * as api from \"./types\";\n")
	w.Writef("import { BaseApiClient, createUrl, type ExtraOptions } from \"./base-client\";\n")
	w.Writef("\n")

	w.Writef("\n")

	w.IndentWritef("export class ApiClient extends BaseApiClient {\n")
	w.Indent()

	w.IndentWritef("url: ClientUrls;\n")
	w.Writef("\n")

	w.IndentWritef("constructor(baseUrl: string) {\n")

	w.Indent()
	w.IndentWritef("super(baseUrl);\n")
	w.IndentWritef("this.url = new ClientUrls(baseUrl);\n")
	w.Unindent()

	w.IndentWritef("}\n")

	for _, endpoint := range serverDef.Endpoints {
		w.IndentWritef("\n")

		switch endpoint.Type {
		case spark.EndpointTypeApi:
			err := g.generateApiEndpoint(&w, &endpoint)
			if err != nil {
				return err
			}
		case spark.EndpointTypeForm:
			err := g.generateFormEndpoint(&w, &endpoint)
			if err != nil {
				return err
			}
		}
	}

	w.Unindent()
	w.IndentWritef("}\n")

	// class ClientUrls {
	//   baseUrl: string;
	//
	//   constructor(baseUrl: string) {
	//     this.baseUrl = baseUrl;
	//   }
	// }

	w.Writef("\n")

	w.IndentWritef("export class ClientUrls {\n")
	w.Indent()

	w.IndentWritef("baseUrl: string;\n")
	w.Writef("\n")

	w.IndentWritef("constructor(baseUrl: string) {\n")

	w.Indent()
	w.IndentWritef("this.baseUrl = baseUrl;\n")
	w.Unindent()

	w.IndentWritef("}\n")

	for _, endpoint := range serverDef.Endpoints {
		w.IndentWritef("\n")

		err := g.generateUrlForEndpoint(&w, &endpoint)
		if err != nil {
			return err
		}
	}

	w.Unindent()
	w.IndentWritef("}\n")
	

	return nil
}
