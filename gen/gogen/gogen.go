package gogen

import (
	"fmt"
	"io"
	"os"
	"path"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/nanoteck137/pyrin/resolve"
)

type Options struct {
	PackageName string
	Output string
}

type Generator struct {
	options Options
}

func New(options ...Options) *Generator {
	gen := &Generator{}

	if len(options) > 0 {
		gen.options = options[0]
	}

	if gen.options.PackageName == "" {
		gen.options.PackageName = "types"
	}

	if gen.options.Output == "" {
		gen.options.Output = "./types/types.go"
	}

	return gen
}

func (gen *Generator) Name() string {
	return "GoGenerator"
}

func (gen *Generator) Generate(resolver *resolve.Resolver) error {
	var b strings.Builder

	fmt.Fprintln(&b, "// THIS FILE IS GENERATED BY PYRIN GOGEN CODE GENERATOR")
	fmt.Fprintln(&b, "package types")
	fmt.Fprintln(&b)

	for _, s := range resolver.ResolvedStructs {
		fmt.Fprintf(&b, "type %s struct {\n", s.Name)

		st := s.Type.(*resolve.TypeStruct)
		for _, f := range st.Fields {
			GenerateField(&b, &f)
		}

		fmt.Fprintln(&b, "}");
		fmt.Fprintln(&b)
	}

	dir := path.Dir(gen.options.Output)
	err := os.MkdirAll(dir, 0755)
	if err != nil {
		return err
	}

	err = os.WriteFile(gen.options.Output, []byte(b.String()), 0644)
	if err != nil {
		return err
	}

	return nil
}

func GenerateType(typ resolve.Type) string {
	switch t := typ.(type) {
	case *resolve.TypeString:
		return "string"
	case *resolve.TypeInt:
		return "int"
	case *resolve.TypeBoolean:
		return "bool"
	case *resolve.TypeStruct:
		return t.Name
	case *resolve.TypeArray:
		return "[]"+GenerateType(t.ElementType)
	}

	return ""
}

func GenerateField(w io.Writer, field *resolve.Field) {
	jsonName := field.Name
	name := strcase.ToCamel(field.Name)

	fmt.Fprintf(w, "\t%s %s `json:\"%s\"`\n", name, GenerateType(field.Type), jsonName);
}
