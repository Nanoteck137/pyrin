package dartg

import (
	"fmt"
	"io"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/nanoteck137/pyrin/spec"
	"github.com/nanoteck137/pyrin/tools/resolve"
	"github.com/nanoteck137/pyrin/utils"
)

func GenerateType(w io.Writer, ty resolve.Type) {
	switch t := ty.(type) {
	case *resolve.TypeString:
		fmt.Fprint(w, "String")
	case *resolve.TypeInt:
		fmt.Fprint(w, "int")
	case *resolve.TypeBoolean:
		fmt.Fprint(w, "bool")
	case *resolve.TypeArray:
		fmt.Fprint(w, "List<")
		GenerateType(w, t.ElementType)
		fmt.Fprint(w, ">")
	case *resolve.TypePtr:
		GenerateType(w, t.BaseType)
		fmt.Fprint(w, "?")
	case *resolve.TypeStruct:
		fmt.Fprint(w, t.Name)
	}
}

var fieldNameMapping = map[string]string{
	"default": "def",
}

func GenerateTypeCode(w io.Writer, resolver *resolve.Resolver) error {
	fmt.Fprintln(w, "// DO NOT EDIT THIS: This file was generated by the Pyrin Dart Generator")
	fmt.Fprintln(w)

	fmt.Fprintln(w, `import 'package:json_annotation/json_annotation.dart';`)
	fmt.Fprintln(w)

	fmt.Fprintln(w, `part 'types.g.dart';`)
	fmt.Fprintln(w)

	for _, s := range resolver.ResolvedStructs {
		switch ty := s.Type.(type) {
		case *resolve.TypeStruct:
			fmt.Fprintln(w, "@JsonSerializable()")
			fmt.Fprintf(w, "class %s {\n", s.Name)
			for _, f := range ty.Fields {
				name := f.Name

				if n, exists := fieldNameMapping[name]; exists {
					name = n
				}

				fmt.Fprintf(w, "  @JsonKey(name: \"%s\")\n", f.Name)
				fmt.Fprint(w, "  final ")
				GenerateType(w, f.Type)
				fmt.Fprintf(w, " %s;\n", name)
			}

			fmt.Fprintln(w)

			// GetTracks(this.page, this.tracks);
			fmt.Fprintf(w, "  %s(", s.Name)
			for i, f := range ty.Fields {
				name := f.Name

				if n, exists := fieldNameMapping[name]; exists {
					name = n
				}

				if i != 0 {
					fmt.Fprint(w, ", ")
				}
				fmt.Fprintf(w, "this.%s", name)
			}

			fmt.Fprint(w, ");\n")

			fmt.Fprintln(w)

			// factory GetTracks.fromJson(Map<String, dynamic> json) => _$GetTracksFromJson(json);
			fmt.Fprintf(w, "  factory %s.fromJson(Map<String, dynamic> json) => _$%sFromJson(json);\n", s.Name, s.Name)

			// Map<String, dynamic> toJson() => _$GetTracksToJson(this);
			fmt.Fprintf(w, "  Map<String, dynamic> toJson() => _$%sToJson(this);\n", s.Name)

			fmt.Fprintln(w, "}")
			fmt.Fprintln(w)
		case *resolve.TypeSameStruct:
			fmt.Fprintf(w, "typedef %s = %s;\n", s.Name, ty.Type.Name)
			fmt.Fprintln(w)
		}
	}

	return nil
}

func generateApiEndpoint(w *utils.CodeWriter, e *spec.ApiEndpoint) error {
	resType := e.ResponseType
	hasBody := resType != ""

	if !hasBody {
		resType = "NoBody"
	}

	funcName := strcase.ToLowerCamel(e.Name)

	var args []string
	parts := strings.Split(e.Path, "/")
	endpointHasArgs := false

	for i, p := range parts {
		if len(p) == 0 {
			continue
		}

		if p[0] == ':' {
			name := p[1:]
			args = append(args, name)

			parts[i] = fmt.Sprintf("$%s", name)

			endpointHasArgs = true
		}
	}

	newEndpoint := strings.Join(parts, "/")

	_ = endpointHasArgs

	w.IWritef("AsyncResultDart<%s, ApiError> %s(", resType, funcName)
	for _, arg := range args {
		w.Writef("String %s, ", arg)
	}

	if e.BodyType != "" {
		w.Writef("%s body, ", e.BodyType)
	}

	w.Writef("{")
	w.Writef("RequestOptions? options")
	w.Writef("}")

	w.Writef(") async {\n")
	w.Indent()

	w.IWritef("final res = await request(\"%s\", \"%s\"", e.Method, newEndpoint)
	if e.BodyType != "" {
		w.Writef(", body: body.toJson()")
	}
	w.Writef(");\n")

	if hasBody {
		w.IWritef("return res.map((success) => %s.fromJson(success));\n", resType)
	} else {
		w.IWritef("return res.map((success) => NoBody());\n")
	}

	w.Unindent()
	w.IWritef("}\n")

	return nil
}

func GenerateClientCode(w io.Writer, server *spec.Server) error {
	cw := utils.CodeWriter{
		Writer:    w,
		IndentStr: "  ",
	}

	cw.IWritef("// DO NOT EDIT THIS: This file was generated by the Pyrin Dart Generator\n")
	cw.IWritef("\n")

	cw.IWritef("import 'package:result_dart/result_dart.dart';\n")
	cw.IWritef("\n")

	cw.IWritef("import './types.dart';\n")
	cw.IWritef("import './base_client.dart';\n")
	cw.IWritef("\n")

	cw.IWritef("class ApiClient extends BaseApiClient {\n")
	cw.Indent()

	cw.IWritef("ApiClient({super.baseUrl});\n")

	for _, endpoint := range server.ApiEndpoints {
		cw.IWritef("\n")

		err := generateApiEndpoint(&cw, &endpoint)
		if err != nil {
			return err
		}
	}

	cw.Unindent()
	cw.IWritef("}\n")

	// for _, endpoint := range server.FormApiEndpoints {
	// 	cw.IWritef("\n")
	//
	// 	_ = endpoint
	//
	// 	// err := generateFormApiEndpoint(&cw, &endpoint)
	// 	// if err != nil {
	// 	// 	return err
	// 	// }
	// }

	return nil
}
